blueprint:
  name: Synthetic Vacuum Controller
  description: |
    This blueprint controls a virtual vacuum using a switch, timer, and runtime.
    It lets any switch, pump, outlet, or other device behave like a programmable robot vaccum cleaner.

    The automation synchronizes the **timer** with the **switch state** and handles paused, resumed, and completed states correctly.

    **How It Works:**  
    - **Start:** Turns on the switch and begins a timer based on the input number's value (in minutes).  
    - **Pause:** Pauses the timer and turns off the switch without cancelling the remaining time.  
    - **Stop:** Cancels the timer and turns off the switch.  
    - **Return to Base:** Cancels the timer and turns off the switch (we may do something with this in future).  
    - **Resuming a Paused Timer:** If the timer is paused, turning on the switch resumes the timer from the remaining time.

    **Entities You Need:**  
    - **Vacuum Entity:** The vacuum or pump to be controlled.  
    - **Switch Entity:** The physical switch controlling the power.  
    - **Timer Entity:** Timer helper to track the runtime.  
    - **Runtime Number Entity:** Input number helper for the duration in minutes. Typically exposed as a slider card in your dashboard view.
    - **Liveupdates Boolean Entity:** Boolean to enable/disable real time duration from the runtime entity (by resetting the timer). Helpful for dynamic runtime slider control.

    **ðŸ’¡ Tip:** Make sure all helpers are created and visible in Home Assistant.

  domain: automation

  input:
    vacuum_entity:
      name: Vacuum
      description: Device - typically a vacuum or pump entity - to be controlled.
      selector:
        entity:
          filter:
            - domain: vacuum

    switch_entity:
      name: Switch
      description: Physical switch or smart plug entity controlling the device power.
      selector:
        entity:
          filter:
            - domain: switch

    timer_entity:
      name: Timer
      description: Timer entity used to track the device's runtime.
      selector:
        entity:
          filter:
            - domain: timer

    runtime_entity:
      name: Runtime
      description: Input number entity representing the runtime duration (in minutes).
      selector:
        entity:
          filter:
            - domain: input_number

    liveupdates_entity:
      name: Live Updates
      description: Boolean that controls whether the runtime slider should be linked in real time..
      selector:
        entity:
          filter:
            - domain: input_boolean

# âœ… Using Variables for Jinja2 Template Safety
variables:
  liveupdates_entity: !input liveupdates_entity
  runtime_entity: !input runtime_entity
  timer_entity: !input timer_entity
  switch_entity: !input switch_entity

# âœ… Triggers (Unchanged)
triggers:
  - trigger: state
    entity_id: !input switch_entity
    to: "on"
    id: switch_on

  - trigger: state
    entity_id: !input switch_entity
    to: "off"
    id: switch_off

  - trigger: state
    entity_id: !input timer_entity
    to: "active"
    id: timer_started

  - trigger: state
    entity_id: !input timer_entity
    to: "idle"
    id: timer_finished

  - trigger: state
    entity_id: !input timer_entity
    to: "paused"
    id: timer_paused

  - trigger: state
    entity_id: !input runtime_entity
    id: runtime_changed

# âœ… Conditions (Unchanged)
conditions: []

# âœ… Actions (Fixed Jinja2 Only, No Entity ID Changes)
actions:
  - choose:
      # When the switch is turned on
      - conditions:
          - condition: trigger
            id: switch_on
        sequence:
          - if:
              - condition: state
                entity_id: !input timer_entity
                state: active
            then:
              - stop: "Timer already active, stopping further actions."

          # If the timer is paused, resume it (Jinja2 Fixed with Variables)
          - if:
              - condition: state
                entity_id: !input timer_entity
                state: paused
            then:
              - action: timer.start
                target:
                  entity_id: !input timer_entity
                data:
                  duration: >
                    {% set remaining = state_attr(timer_entity, 'remaining') %}
                    {{ remaining if remaining else "0" }}
              - stop: "Resumed paused timer."

          # Otherwise, start a new timer (Jinja2 Fixed with Variables)
          - action: timer.start
            target:
              entity_id: !input timer_entity
            data:
              duration: >
                {% set runtime = states(runtime_entity) | float | int * 60 %}
                {{ runtime }}

      # When the switch is turned off, cancel the timer unless it is paused
      - conditions:
          - condition: trigger
            id: switch_off
        sequence:
          - if:
              - condition: not
                conditions:
                  - condition: state
                    entity_id: !input timer_entity
                    state: paused
            then:
              - action: timer.cancel
                target:
                  entity_id: !input timer_entity
              - action: switch.turn_off
                target:
                  entity_id: !input switch_entity

      # When the timer starts, ensure the switch is on
      - conditions:
          - condition: trigger
            id: timer_started
        sequence:
          - if:
              - condition: state
                entity_id: !input switch_entity
                state: "off"
            then:
              - action: switch.turn_on
                target:
                  entity_id: !input switch_entity

      # When the timer finishes, turn off the switch
      - conditions:
          - condition: trigger
            id: timer_finished
        sequence:
          - if:
              - condition: state
                entity_id: !input switch_entity
                state: "on"
            then:
              - action: switch.turn_off
                target:
                  entity_id: !input switch_entity

      # When the timer is paused, turn off the switch but keep the timer paused
      - conditions:
          - condition: trigger
            id: timer_paused
        sequence:
          - if:
              - condition: state
                entity_id: !input switch_entity
                state: "on"
            then:
              - action: switch.turn_off
                target:
                  entity_id: !input switch_entity

        # When the runtime is altered
      - conditions:
          - condition: trigger
            id: runtime_changed
        sequence:
          - action: logbook.log
            data:
              name: "Vactimer Debug"
              message: >
                Runtime change context user
                {{ trigger.to_state.context.user_id| default('automation') }}
          # Align timer and switch to runtime if live updates are enabled, and this was ui initiated
          - if:
              - condition: template
                value_template: "{{ (states(liveupdates_entity) == 'on') and (states(trigger.to_state.context.user_id) != 'null') }}"
            then:
              # If the runtime is set to zero, cancel the timer and turn off the switch
              - if:
                - condition: template
                  value_template: "{{ states(runtime_entity) | int <= 0 }}"
                then:
                  - action: switch.turn_off
                    target:
                      entity_id: !input switch_entity
                  - action: timer.cancel
                    target:
                      entity_id: !input timer_entity
                else:
                  # Otherwise, switch on and start the timer with duration set to runtime 
                  - action: timer.start
                    target:
                      entity_id: !input timer_entity
                    data:
                      duration: >
                        {% set runtime = states(runtime_entity) | float | int * 60 %}
                        {{ runtime }}
                  - action: switch.turn_on
                    target:
                      entity_id: !input switch_entity
          - if:
              - condition: template
                value_template: "{{ (states(switch_entity) == 'on') }}"
            then:
              # If the runtime is set changed while already switched on, reset the timer regardless of live update status
              - action: timer.start
                target:
                  entity_id: !input timer_entity
                data:
                  duration: >
                    {% set runtime = states(runtime_entity) | float | int * 60 %}
                    {{ runtime }}

mode: restart
